<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üéØ WinGo Predictor Pro</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{ --gold:#FFD700; --gold-soft:#f5d46b; --bg1:#0f0f0f; --bg2:#000;
           --card:#111; --muted:#9ca3af; --danger:#f87171; --ok:#22c55e; }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:'Segoe UI',system-ui,sans-serif;
          background:linear-gradient(to bottom right,var(--bg1),var(--bg2)); color:#fff; text-align:center; }
    header{ background:#000; padding:16px 0; box-shadow:0 2px 8px var(--gold) }
    header h1{ margin:0; font-size:28px; color:var(--gold) }
    .container{ padding:26px 16px; max-width:1150px; margin:0 auto }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:16px }
    @media (max-width:980px){ .row{ grid-template-columns:1fr } }
    .card{ background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:18px; text-align:left;
           box-shadow:0 0 15px rgba(0,0,0,.35) }
    label{ font-weight:600 }
    input, select{ margin-top:8px; width:100%; padding:10px 12px; border-radius:10px;
           border:2px solid var(--gold); background:#000; color:#fff; font-size:16px; }
    .btn{ margin-top:10px; background:var(--gold); color:#000; border:0; border-radius:10px;
          padding:10px 16px; font-weight:700; cursor:pointer; box-shadow:0 0 12px var(--gold) }
    .btn.secondary{ background:#1f2937; color:#fff; box-shadow:none; border:1px solid #333 }
    .btn.inline{ margin-left:8px }
    .meta{ font-size:13px; color:var(--muted); margin-top:6px }
    .result-box{ background:#0b0b0b; border:1px solid #1f2937; border-radius:14px; padding:16px; display:none }
    .line{ height:8px; background:#222; border-radius:6px; overflow:hidden; margin-top:8px }
    .bar{ height:8px; background:linear-gradient(90deg,var(--gold-soft),var(--gold)); width:0% }
    .kv{ display:flex; justify-content:space-between; gap:12px }
    .kv div{ flex:1 }
    .val{ font-weight:800; color:var(--gold) }
    .thinking{ margin-top:10px; color:#FFEB3B; animation:blink 1s infinite }
    @keyframes blink{ 0%{opacity:.2} 50%{opacity:1} 100%{opacity:.2} }
    .tag{ display:inline-block; padding:4px 8px; border:1px solid #333; border-radius:999px; font-size:12px; color:#ddd }
    .history{ font-size:12px; color:#cbd5e1; max-height:160px; overflow:auto }
    .danger{ color:var(--danger) } .ok{ color:var(--ok) }
    .grid3{ display:grid; grid-template-columns:2fr 1fr 1fr; gap:12px }
    @media (max-width:980px){ .grid3{ grid-template-columns:1fr } }
  </style>
</head>
<body>
  <header><h1>üéØ WinGo Predictor Pro</h1></header>

  <div class="container">
    <!-- CONTROLS -->
    <div class="card">
      <label for="inputNumbers">üî¢ <b>Enter Previous Numbers</b> (comma or space separated)</label>
      <input id="inputNumbers" placeholder="e.g. 3,7,1,9,4,0,2,8,6,5" />
      <div class="meta">Tip: ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ 40‚Äì50 ‡§π‡§æ‡§≤‡§ø‡§Ø‡§æ ‡§°‡•ç‡§∞‡•â ‡§°‡§æ‡§≤‡•á‡§Ç ‡§Ø‡§æ Auto-Fetch ‡§ö‡§æ‡§≤‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§</div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">
        <button class="btn" id="btnPredict">üîÆ Predict</button>
        <button class="btn secondary" id="btnClear">Clear</button>
        <button class="btn secondary" id="btnCopy">Copy Result</button>
        <span class="tag" id="apiStatus">API: auto</span>
        <span class="tag" id="autoStatus">Auto: off</span>
      </div>
      <div id="thinking" class="thinking" style="display:none">ü§ñ AI Thinking...</div>
    </div>

    <!-- AUTO FETCH SETTINGS -->
    <div class="card" style="margin-top:16px">
      <h3 style="margin:0 0 8px">‚öôÔ∏è Auto-Fetch Settings</h3>
      <div class="grid3">
        <div>
          <label>Results API URL</label>
          <input id="afUrl" placeholder="https://example.com/api/wingo/latest?limit=60" />
          <div class="meta">JSON: {"results":[...]} ‡§Ø‡§æ CSV: "3,7,1,..."</div>
        </div>
        <div>
          <label>Format</label>
          <select id="afFmt">
            <option value="json" selected>JSON</option>
            <option value="csv">CSV</option>
          </select>
          <label style="margin-top:8px">JSON Key</label>
          <input id="afKey" value="results" />
        </div>
        <div>
          <label>Fetch Count</label>
          <input id="afCount" type="number" min="10" max="200" value="50" />
          <label style="margin-top:8px">Poll (sec)</label>
          <input id="afPoll" type="number" min="2" max="30" value="5" />
        </div>
      </div>

      <div class="grid3" style="margin-top:12px">
        <div>
          <label>Period (sec) ‚Äî optional</label>
          <input id="afPeriod" type="number" min="30" max="300" placeholder="e.g. 60" />
        </div>
        <div>
          <label>Lead (sec) ‚Äî optional</label>
          <input id="afLead" type="number" min="1" max="20" placeholder="e.g. 10" />
        </div>
        <div style="display:flex; align-items:end; gap:8px">
          <button class="btn" id="btnAutoToggle">‚ñ∂ Start Auto-Fetch</button>
          <button class="btn secondary" id="btnPredictNow">Predict Now</button>
        </div>
      </div>
      <div class="meta">‚ÄúOn New Result‚Äù ‡§Æ‡•ã‡§°: ‡§Ü‡§ñ‡§º‡§ø‡§∞‡•Ä ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡§¶‡§≤‡§§‡•á ‡§π‡•Ä Predict‡•§ Period+Lead ‡§¶‡•á‡§®‡•á ‡§™‡§∞ ‡§Ö‡§ó‡§≤‡§æ ‡§∞‡§æ‡§â‡§Ç‡§° ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§®‡•á ‡§∏‡•á Lead ‡§∏‡•á‡§ï‡§Ç‡§° ‡§™‡§π‡§≤‡•á Predict ‡§∂‡•á‡§°‡•ç‡§Ø‡•Ç‡§≤ ‡§π‡•ã‡§ó‡§æ‡•§</div>
    </div>

    <!-- RESULT -->
    <div class="row" style="margin-top:16px">
      <div class="card">
        <div class="result-box" id="resultBox">
          <div class="kv">
            <div>üî¢ Number<br><span class="val" id="vNum">‚Äì</span></div>
            <div>üìè Size<br><span class="val" id="vSize">‚Äì</span></div>
            <div>üéØ Opposite backup<br><span class="val" id="vBackup">‚Äì</span></div>
          </div>
          <div style="margin-top:10px">üß† Confidence</div>
          <div class="line"><div class="bar" id="confBar"></div></div>
          <div class="kv" style="margin-top:10px">
            <div>üü© Big<br><span class="val" id="vBig">‚Äì</span></div>
            <div>üü• Small<br><span class="val" id="vSmall">‚Äì</span></div>
          </div>
        </div>
      </div>
      <div class="card">
        <h3 style="margin:0 0 8px">üìä Probability (0‚Äì9)</h3>
        <canvas id="probChart" height="210"></canvas>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="card">
        <h3 style="margin:0 0 8px">‚öñÔ∏è Big vs Small</h3>
        <canvas id="bsChart" height="210"></canvas>
      </div>
      <div class="card">
        <h3 style="margin:0 0 8px">üßæ Input Summary</h3>
        <div id="summary" class="meta">‚Äî</div>
        <h3 style="margin:16px 0 8px">üïò Recent Predictions</h3>
        <div id="hist" class="history">‚Äî</div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const API_BASE = "";  // e.g. "https://wingo-api.onrender.com"
    // =====================

    let lastInput = "";
    let probChart = null, bsChart = null;
    const el = id => document.getElementById(id);
    const clamp01 = x => Math.max(0, Math.min(1, x));
    const fmtPct = x => (x*100).toFixed(1) + '%';

    // ---------- parsing & utils ----------
    function parseInput(str){
      if(!str) return [];
      return str.replace(/,/g,' ').split(/\s+/).filter(Boolean).map(v=>{
        let n = parseInt(v,10); if(Number.isNaN(n)) n = 0;
        return Math.max(0, Math.min(9, n));
      });
    }
    function freqMap(arr){ const f = Array(10).fill(0); arr.forEach(n=>f[n]++); return f; }

    // ========= ADVANCED SMART FALLBACK =========
    function smartFallback(history){
      const n = history.length;
      const alpha = 0.6, decay = 0.95;
      const uni = Array(10).fill(alpha);
      for(let i=0;i<n;i++){ uni[history[i]] += Math.pow(decay, n-1-i); }
      const uS = uni.reduce((a,b)=>a+b,0)||1; let pUni = uni.map(x=>x/uS);

      const trans = Array.from({length:10},()=>Array(10).fill(alpha/10));
      for(let i=1;i<n;i++){ const age=n-1-i; trans[history[i-1]][history[i]] += Math.pow(decay, age); }
      const last = history[n-1] ?? 0;
      let row = trans[last].slice(); const rS=row.reduce((a,b)=>a+b,0)||1; row=row.map(x=>x/rS);

      const lambda = Math.min(0.85, 0.40 + 0.45*(n/(n+8)));
      let probs = row.map((r,i)=> lambda*r + (1-lambda)*pUni[i]);

      const K=Math.min(6,n); if(K>=2){
        const recent = history.slice(-K);
        const br = recent.filter(v=>v>=5).length / K;
        const sB=0.9+0.25*br, sS=0.9+0.25*(1-br);
        for(let i=0;i<10;i++) probs[i]*=(i>=5?sB:sS);
      }
      let streak=1; for(let i=n-1;i>0&&history[i]===history[i-1];i--) streak++;
      if(streak>2){ const factor=Math.max(0.85,1-0.04*(streak-2)); probs[last]*=factor; }

      const temp=1.07; probs=probs.map(p=>Math.pow(p,1/temp));
      const s=probs.reduce((a,b)=>a+b,0)||1; probs=probs.map(p=>p/s);

      const predicted = probs.indexOf(Math.max(...probs));
      const pBig = probs.slice(5,10).reduce((a,b)=>a+b,0); const pSmall=1-pBig;
      let H=0; for(const p of probs){ if(p>0) H+=-p*Math.log(p); } const confidence=clamp01(1-(H/Math.log(10)));
      const argmaxRange=(arr,a,b)=>{ let best=a,bv=-1; for(let i=a;i<b;i++) if(arr[i]>bv){bv=arr[i];best=i;} return best; };
      const backup = predicted>=5 ? argmaxRange(probs,0,5) : argmaxRange(probs,5,10);
      return {predicted, probs, big:pBig, small:pSmall, confidence, backup};
    }
    // ===========================================

    function renderCharts(probs, big, small){
      const labels = [...Array(10).keys()].map(String);
      const data = probs.map(p => Math.round(p*1000)/10);
      const pctx = el('probChart').getContext('2d');
      if (probChart) probChart.destroy();
      probChart = new Chart(pctx,{ type:'bar',
        data:{ labels, datasets:[{ label:'Probability (%)', data }] },
        options:{ responsive:true, scales:{ y:{ beginAtZero:true, title:{display:true,text:'%'} }, x:{ title:{display:true,text:'Digit'} } } }
      });
      const bctx = el('bsChart').getContext('2d');
      if (bsChart) bsChart.destroy();
      bsChart = new Chart(bctx,{ type:'doughnut',
        data:{ labels:['Big','Small'], datasets:[{ data:[Math.round(big*100), Math.round(small*100)] }] },
        options:{ responsive:true, cutout:'60%' }
      });
    }

    function renderResult(resp){
      el('resultBox').style.display = 'block';
      el('vNum').textContent = resp.predicted;
      el('vSize').textContent = resp.predicted>=5 ? 'Big' : 'Small';
      el('vBackup').textContent = resp.backup;
      el('confBar').style.width = (resp.confidence*100).toFixed(1)+'%';
      el('vBig').textContent = fmtPct(resp.big);
      el('vSmall').textContent = fmtPct(resp.small);
      renderCharts(resp.probs, resp.big, resp.small);
      const stamp = new Date().toLocaleTimeString();
      const line = `‚è± ${stamp} ‚Üí #${resp.predicted} (${resp.predicted>=5?'Big':'Small'}) ‚Ä¢ conf ${Math.round(resp.confidence*100)}% ‚Ä¢ backup ${resp.backup}`;
      const h = el('hist'); h.innerHTML = (h.innerHTML==='‚Äî'?'':h.innerHTML)+'<div>'+line+'</div>';
    }

    async function callServer(history){
      const payload = { numbers: history.join(',') };
      const url = (API_BASE || '') + '/predict';
      const res = await fetch(url,{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
      if(!res.ok) throw new Error((await res.json()).error || 'Server error');
      const data = await res.json();
      const probsArr = Array.isArray(data.probs) ? data.probs
        : Array.from({length:10},(_,i)=> i===data.predicted_number ? 0.35 : 0.65/9);
      const predicted = (data.predicted ?? data.predicted_number);
      const big = clamp01((data.big_small?.big) ?? data.big_probability ?? 0.5);
      const small = clamp01((data.big_small?.small) ?? data.small_probability ?? (1-big));
      const confidence = clamp01(data.confidence ?? Math.max(...probsArr));
      const oppIdx = predicted>=5
        ? probsArr.slice(0,5).indexOf(Math.max(...probsArr.slice(0,5)))
        : 5 + probsArr.slice(5,10).indexOf(Math.max(...probsArr.slice(5,10)));
      return { predicted, probs:probsArr, big, small, confidence, backup: oppIdx };
    }

    function summarizeInput(arr){
      if(arr.length===0){ el('summary').textContent='‚Äî'; return; }
      const f = freqMap(arr);
      const max = Math.max(...f), min = Math.min(...f);
      const hot = f.map((c,i)=>[c,i]).filter(([c])=>c===max).map(([,i])=>i).join(', ');
      const cold = f.map((c,i)=>[c,i]).filter(([c])=>c===min).map(([,i])=>i).join(', ');
      el('summary').innerHTML = `Len: <b>${arr.length}</b> ‚Ä¢ Unique: <b>${[...new Set(arr)].length}</b><br/>Hot: <b>${hot||'‚Äî'}</b> ‚Ä¢ Cold: <b>${cold||'‚Äî'}</b>`;
    }

    // ---------- Manual UI ----------
    el('btnPredict').addEventListener('click', async ()=>{
      const raw = el('inputNumbers').value.trim();
      const hist = parseInput(raw);
      summarizeInput(hist);
      if(hist.length===0){ alert('‡§ï‡•É‡§™‡§Ø‡§æ ‡§®‡§Ç‡§¨‡§∞ ‡§°‡§æ‡§≤‡•á‡§Ç'); return; }
      if(raw===lastInput){ /* allow manual repeat */ }
      lastInput = raw;

      el('resultBox').style.display='none';
      el('thinking').style.display='block';

      try{
        let resp;
        try{
          resp = await callServer(hist);
          el('apiStatus').textContent = 'API: server';
          el('apiStatus').className = 'tag ok';
        }catch(_e){
          resp = smartFallback(hist);
          el('apiStatus').textContent = 'API: fallback';
          el('apiStatus').className = 'tag danger';
        }
        renderResult(resp);
      }catch(err){ alert('Error: '+ err.message); }
      finally{ el('thinking').style.display='none'; }
    });

    el('btnPredictNow').addEventListener('click', ()=> el('btnPredict').click());

    el('btnClear').addEventListener('click', ()=>{
      el('inputNumbers').value=''; el('resultBox').style.display='none'; el('summary').textContent='‚Äî';
    });

    el('btnCopy').addEventListener('click', async ()=>{
      const n = el('vNum').textContent; if(!n || n==='‚Äì'){ alert('‡§™‡§π‡§≤‡•á Predict ‡§ï‡§∞‡•á‡§Ç'); return; }
      const text = `Number: ${el('vNum').textContent}, Size: ${el('vSize').textContent}, Big:${el('vBig').textContent}, Small:${el('vSmall').textContent}`;
      try{ await navigator.clipboard.writeText(text); alert('Copied!'); }catch{ alert('Copy failed'); }
    });

    // ---------- Auto-Fetch Engine ----------
    let autoTimer = null, nextTimer = null, lastSeenTail = null;

    async function fetchHistoryOnce(){
      const url = el('afUrl').value.trim();
      const fmt = el('afFmt').value;
      const key = el('afKey').value.trim() || 'results';
      const count = Math.max(10, parseInt(el('afCount').value||'50',10));

      if(!url){ throw new Error('Results API URL ‡§ñ‡§æ‡§≤‡•Ä ‡§π‡•à'); }

      const res = await fetch(url, { cache: 'no-store' });
      if(!res.ok) throw new Error('Results API error');
      const txt = await res.text();

      let arr = [];
      try{
        if(fmt==='json'){
          const obj = JSON.parse(txt);
          const raw = obj[key];
          if(!Array.isArray(raw)) throw new Error('JSON key ‡§Æ‡•á‡§Ç array ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ');
          arr = raw;
        }else{
          arr = txt.split(/,|\s+/).filter(Boolean);
        }
      }catch(e){
        throw new Error('Parse error: '+e.message);
      }

      const hist = Array.from(arr).map(v=>parseInt(v,10)).filter(v=>Number.isFinite(v)).map(v=>Math.max(0,Math.min(9,v)));
      const trimmed = hist.slice(-count);
      if(trimmed.length===0) throw new Error('API ‡§∏‡•á valid ‡§®‡§Ç‡§¨‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•á');

      // Update input box
      el('inputNumbers').value = trimmed.join(',');
      summarizeInput(trimmed);
      return trimmed;
    }

    function scheduleNext(periodSec, leadSec){
      if(nextTimer) { clearTimeout(nextTimer); nextTimer=null; }
      if(!periodSec || !leadSec) return;
      // Predict lead ‡§∏‡•á‡§ï‡§Ç‡§° ‡§™‡§π‡§≤‡•á: ‡§Ö‡§≠‡•Ä ‡§∏‡•á period-lead ‡§™‡§∞
      const delay = Math.max(0, (periodSec - leadSec) * 1000);
      nextTimer = setTimeout(()=> el('btnPredict').click(), delay);
    }

    async function autoTick(){
      try{
        const hist = await fetchHistoryOnce();
        const tail = hist[hist.length-1];
        const periodSec = parseInt(el('afPeriod').value||'0',10);
        const leadSec   = parseInt(el('afLead').value||'0',10);

        // On New Result -> Predict immediately
        if(lastSeenTail===null || tail!==lastSeenTail){
          lastSeenTail = tail;
          el('btnPredict').click();
          // If using period clock, also schedule next prediction
          if(periodSec && leadSec){ scheduleNext(periodSec, leadSec); }
        }
      }catch(e){
        console.warn(e.message);
      }
    }

    function startAuto(){
      if(autoTimer) return;
      const poll = Math.max(2, parseInt(el('afPoll').value||'5',10));
      autoTimer = setInterval(autoTick, poll*1000);
      el('autoStatus').textContent = 'Auto: on';
      el('btnAutoToggle').textContent = '‚è∏ Stop Auto-Fetch';
      autoTick(); // immediate
    }
    function stopAuto(){
      if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
      if(nextTimer){ clearTimeout(nextTimer); nextTimer=null; }
      el('autoStatus').textContent = 'Auto: off';
      el('btnAutoToggle').textContent = '‚ñ∂ Start Auto-Fetch';
    }

    el('btnAutoToggle').addEventListener('click', ()=>{
      if(autoTimer) stopAuto(); else startAuto();
    });
  </script>
</body>
</html>
